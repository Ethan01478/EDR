#include "pch.h" // 如果你的專案沒用預編譯標頭，可以拿掉這行
#include "MalwareScanner.h"
#include "EmbeddedRules.h" // 這裡面應該定義了 INTERNAL_YARA_RULES
#include <Windows.h>
#include <iostream>
#include <codecvt>
#include <locale>
#include <vector>

// 引入 YARA-X C API
extern "C" {
#include "yara_x.h"
}

// ---------------------------------------------------------
// 輔助函式：YARA Callback
// ---------------------------------------------------------
static void OnMatchCallback(const YRX_RULE* rule, void* user_data) {
    bool* isMatched = static_cast<bool*>(user_data);
    *isMatched = true;

    // [DEBUG] 如果想看哪個規則觸發，可以解開下面這行
    // const char* name = yrx_rule_identifier(rule);
    // std::cout << "[YARA MATCH] Rule: " << (name ? name : "Unknown") << std::endl;
}

// ---------------------------------------------------------
// 建構子
// ---------------------------------------------------------
MalwareScanner::MalwareScanner() : m_scanner(nullptr), m_rules(nullptr) {
    YRX_COMPILER* compiler = nullptr;
    YRX_RULES* rules = nullptr;
    YRX_SCANNER* scanner = nullptr;

    // 1. 建立編譯器
    if (yrx_compiler_create(0, &compiler) != 0) {
        // std::cerr << "[Error] Failed to create YARA compiler." << std::endl;
        return;
    }

    // 2. 加入內嵌規則 (來自 EmbeddedRules.h)
    if (yrx_compiler_add_source(compiler, INTERNAL_YARA_RULES) != 0) {
        // std::cerr << "[Error] Failed to compile YARA rules." << std::endl;
        yrx_compiler_destroy(compiler);
        return;
    }

    // 3. 建置規則
    rules = yrx_compiler_build(compiler);
    if (rules == nullptr) {
        // std::cerr << "[Error] Failed to build YARA rules." << std::endl;
        yrx_compiler_destroy(compiler);
        return;
    }

    yrx_compiler_destroy(compiler);

    // 4. 建立掃描器
    if (yrx_scanner_create(rules, &scanner) != 0) {
        // std::cerr << "[Error] Failed to create YARA scanner." << std::endl;
        yrx_rules_destroy(rules);
        return;
    }

    m_rules = rules;
    m_scanner = scanner;
}

// ---------------------------------------------------------
// 解構子
// ---------------------------------------------------------
MalwareScanner::~MalwareScanner() {
    std::lock_guard<std::mutex> lock(m_scanMutex);
    if (m_scanner) {
        yrx_scanner_destroy(static_cast<YRX_SCANNER*>(m_scanner));
        m_scanner = nullptr;
    }
    if (m_rules) {
        yrx_rules_destroy(static_cast<YRX_RULES*>(m_rules));
        m_rules = nullptr;
    }
}

// ---------------------------------------------------------
// 檔案掃描 (整合 Device Path 修正)
// ---------------------------------------------------------
bool MalwareScanner::ScanFile(const std::wstring& filePath) {
    std::lock_guard<std::mutex> lock(m_scanMutex); // 確保執行緒安全

    if (!m_scanner || !m_rules) return false;
    if (filePath.empty()) return false;

    // =========================================================
    // [FIX] 核心路徑修正 (Device Path Correction)
    // =========================================================
    // 如果路徑是核心格式 (如 \Device\HarddiskVolume2\...)，
    // 必須加上 "\\?\GLOBALROOT" 前綴才能被 CreateFile / fopen 讀取。
    std::wstring scanPath = filePath;
    if (scanPath.find(L"\\Device\\") == 0) {
        scanPath = L"\\\\?\\GLOBALROOT" + scanPath;
    }

    // =========================================================
    // [FIX] UTF-16 轉 UTF-8 (YARA-X 只吃 UTF-8 路徑)
    // =========================================================
    int utf8Len = WideCharToMultiByte(CP_UTF8, 0, scanPath.c_str(), -1, nullptr, 0, nullptr, nullptr);
    if (utf8Len == 0) return false;

    std::string utf8Path(utf8Len, 0);
    WideCharToMultiByte(CP_UTF8, 0, scanPath.c_str(), -1, &utf8Path[0], utf8Len, nullptr, nullptr);

    // 移除 string 尾部的 \0
    if (!utf8Path.empty() && utf8Path.back() == '\0') {
        utf8Path.pop_back();
    }

    // =========================================================
    // 執行掃描
    // =========================================================
    bool isMalware = false;

    // 設定 Callback
    yrx_scanner_on_matching_rule(static_cast<YRX_SCANNER*>(m_scanner), OnMatchCallback, &isMalware);

    // 掃描檔案
    int result = yrx_scanner_scan_file(static_cast<YRX_SCANNER*>(m_scanner), utf8Path.c_str());

    if (result != 0) {
        // [DEBUG] 錯誤碼 2 = File Not Found，代表 Process 可能已經刪除自身
        // std::wcerr << L"[Warning] YARA ScanFile Error: " << result << L" Path: " << scanPath << std::endl;
        return false;
    }

    return isMalware;
}

// ---------------------------------------------------------
// 記憶體掃描 (針對加殼/混淆 Malware)
// ---------------------------------------------------------
bool MalwareScanner::ScanProcessMemory(DWORD pid) {
    std::lock_guard<std::mutex> lock(m_scanMutex); // 確保執行緒安全

    if (!m_scanner || !m_rules) return false;

    // 1. 打開 Process (需要 VM_READ 權限)
    HANDLE hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, FALSE, pid);
    if (!hProcess) {
        // 如果失敗，通常是因為 Process 已經結束，或是受保護的系統行程
        return false;
    }

    bool isMalware = false;
    unsigned char* addr = 0;
    MEMORY_BASIC_INFORMATION mbi;

    // 設定 Callback
    yrx_scanner_on_matching_rule(static_cast<YRX_SCANNER*>(m_scanner), OnMatchCallback, &isMalware);

    // 2. 遍歷記憶體區塊 (Memory Walking)
    while (VirtualQueryEx(hProcess, addr, &mbi, sizeof(mbi))) {
        // 我們只關心：
        // (1) 已提交 (MEM_COMMIT) - 實際有資料的
        // (2) 可讀取 (Readable) - 避免 Access Violation
        // (3) 通常惡意 Payload 會在可執行區域 (EXECUTE_READ / EXECUTE_READWRITE)
        bool isInteresting = (mbi.State == MEM_COMMIT) &&
            (mbi.Protect & (PAGE_READONLY | PAGE_READWRITE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE));

        if (isInteresting) {
            std::vector<uint8_t> buffer;
            buffer.resize(mbi.RegionSize);
            SIZE_T bytesRead = 0;

            // 讀取該區塊記憶體
            if (ReadProcessMemory(hProcess, mbi.BaseAddress, buffer.data(), mbi.RegionSize, &bytesRead)) {

                // 使用 YARA 掃描這塊記憶體 Buffer
                yrx_scanner_scan(
                    static_cast<YRX_SCANNER*>(m_scanner),
                    buffer.data(),
                    buffer.size()
                );

                if (isMalware) {
                    // std::wcout << L"[Detected] Malware found in memory at address: " << mbi.BaseAddress << std::endl;
                    break; // 抓到就收工
                }
            }
        }

        // 移動到下一個區塊
        addr += mbi.RegionSize;
    }

    CloseHandle(hProcess);
    return isMalware;
}