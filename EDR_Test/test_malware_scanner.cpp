#include <pch.h>
#include <gtest/gtest.h>
#include <Windows.h>
#include <vector>
#include <string>

// 引入被測模組
#include "MalwareScanner.h"

// ------------------------------------------------------------------------
// 測試夾具 (Test Fixture)
// 負責在每個測試前建立 Scanner 實例
// ------------------------------------------------------------------------
class MalwareScannerTest : public ::testing::Test {
protected:
    MalwareScanner* scanner;

    void SetUp() override {
        // 每次測試前初始化 Scanner
        scanner = new MalwareScanner();
    }

    void TearDown() override {
        // 測試後清理
        delete scanner;
    }

    // 輔助函式：將字串拆開重組 (Obfuscation)
    // 目的：避免這個測試程式的 .exe 靜態檔案本身就被 YARA 偵測到
    // 如果直接在程式碼寫 "BOMBE_MAL_FLAG_"，編譯出來的測試檔就會被當成病毒
    std::string BuildMalwareSignature() {
        std::string part1 = "BOMBE_";
        std::string part2 = "MAL_";
        std::string part3 = "FLAG_";
        return part1 + part2 + part3; // 回傳 "BOMBE_MAL_FLAG_"
    }
};

// ------------------------------------------------------------------------
// Test Case 1: 測試掃描不存在的 PID
// ------------------------------------------------------------------------
TEST_F(MalwareScannerTest, ScanInvalidPID) {
    // 給一個幾乎不可能存在的 PID (例如 999999)
    DWORD invalidPid = 999999;

    // 預期回傳 false (且不應崩潰)
    bool result = scanner->ScanProcessMemory(invalidPid);
    EXPECT_FALSE(result);
}

// ------------------------------------------------------------------------
// Test Case 2: 模擬惡意特徵並掃描 (Infected Scan)
// ------------------------------------------------------------------------
TEST_F(MalwareScannerTest, ScanInfectedSelf) {
    DWORD myPid = GetCurrentProcessId();

    // 1. 準備惡意特徵 (對應 EmbeddedRules.h 裡的 $strong_2 或 $uniq_2)
    std::string payload = BuildMalwareSignature();
    size_t payloadSize = payload.size();

    // 2. 在記憶體中配置一塊區域 (模擬惡意程式解壓縮 payload 到 Heap)
    // 使用 VirtualAlloc 確保它是一塊獨立的 Memory Region
    void* pMemory = VirtualAlloc(NULL, 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    ASSERT_NE(pMemory, nullptr) << "Failed to allocate memory for test.";

    // 3. 將特徵寫入記憶體
    memcpy(pMemory, payload.c_str(), payloadSize);

    // [Debug] 印出位置方便除錯
    // std::wcout << L"[Test] Injected payload at: " << pMemory << std::endl;

    // 4. 執行掃描
    // 因為 ScanProcessMemory 會遍歷所有 Commit 且 Readable 的區域，
    // 它應該會讀到 pMemory 指向的這塊，並由 YARA 觸發規則
    bool result = scanner->ScanProcessMemory(myPid);

    // 5. 驗證結果
    EXPECT_TRUE(result) << "Scanner failed to detect injected memory payload.";

    // 6. 清理記憶體
    VirtualFree(pMemory, 0, MEM_RELEASE);
}